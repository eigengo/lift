// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
import ProtocolBuffers

internal struct DeviceSensorDataRoot {
  internal static var sharedInstance : DeviceSensorDataRoot {
   struct Static {
       static let instance : DeviceSensorDataRoot = DeviceSensorDataRoot()
   }
   return Static.instance
  }
  internal var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  internal func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

internal func == (lhs: MultipleDeviceSensorData.SingleDeviceSensorData, rhs: MultipleDeviceSensorData.SingleDeviceSensorData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSource == rhs.hasSource) && (!lhs.hasSource || lhs.source == rhs.source)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

internal func == (lhs: MultipleDeviceSensorData, rhs: MultipleDeviceSensorData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.singleDeviceSensorData == rhs.singleDeviceSensorData)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final internal class MultipleDeviceSensorData : GeneratedMessage {


  //Nested type declaration start

    final internal class SingleDeviceSensorData : GeneratedMessage {
      private(set) var source:MultipleDeviceSensorData.Source = MultipleDeviceSensorData.Source.Head
      private(set) var hasSource:Bool = false
      private(set) var hasData:Bool = false
      private(set) var data:NSData = NSData()

      required internal init() {
           super.init()
      }
      override internal func isInitialized() -> Bool {
        if !hasSource {
          return false
        }
        if !hasData {
          return false
        }
       return true
      }
      override internal func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasSource {
          output.writeEnum(1, value:source.rawValue)
        }
        if hasData {
          output.writeData(2, value:data)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override internal func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if (hasSource) {
          size += source.rawValue.computeEnumSize(1)
        }
        if hasData {
          size += data.computeDataSize(2)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      internal class func parseFromData(data:NSData) -> MultipleDeviceSensorData.SingleDeviceSensorData {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builder().mergeFromData(data, extensionRegistry:DeviceSensorDataRoot.sharedInstance.extensionRegistry).build()
      }
      internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> MultipleDeviceSensorData.SingleDeviceSensorData {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      internal class func parseFromInputStream(input:NSInputStream) -> MultipleDeviceSensorData.SingleDeviceSensorData {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builder().mergeFromInputStream(input).build()
      }
      internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MultipleDeviceSensorData.SingleDeviceSensorData {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      internal class func parseFromCodedInputStream(input:CodedInputStream) -> MultipleDeviceSensorData.SingleDeviceSensorData {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builder().mergeFromCodedInputStream(input).build()
      }
      internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MultipleDeviceSensorData.SingleDeviceSensorData {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      internal class func builder() -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
        return MultipleDeviceSensorData.SingleDeviceSensorData.classBuilder() as MultipleDeviceSensorData.SingleDeviceSensorDataBuilder
      }
      internal func builder() -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
        return classBuilder() as MultipleDeviceSensorData.SingleDeviceSensorDataBuilder
      }
      internal override class func classBuilder() -> MessageBuilder {
        return MultipleDeviceSensorData.SingleDeviceSensorDataBuilder()
      }
      internal override func classBuilder() -> MessageBuilder {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builder()
      }
      internal func toBuilder() -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builderWithPrototype(self)
      }
      internal class func builderWithPrototype(prototype:MultipleDeviceSensorData.SingleDeviceSensorData) -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builder().mergeFrom(prototype)
      }
      override internal func writeDescriptionTo(inout output:String, indent:String) {
        if (hasSource) {
          output += "\(indent) source: \(source.rawValue)\n"
        }
        if hasData {
          output += "\(indent) data: \(data) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override internal var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasSource {
                 hashCode = (hashCode &* 31) &+ Int(source.rawValue)
              }
              if hasData {
                 hashCode = (hashCode &* 31) &+ data.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override internal class func className() -> String {
          return "MultipleDeviceSensorData.SingleDeviceSensorData"
      }
      override internal func className() -> String {
          return "MultipleDeviceSensorData.SingleDeviceSensorData"
      }
      override internal func classMetaType() -> GeneratedMessage.Type {
          return MultipleDeviceSensorData.SingleDeviceSensorData.self
      }


      //Meta information declaration end

    }

    final internal class SingleDeviceSensorDataBuilder : GeneratedMessageBuilder {
      private var builderResult:MultipleDeviceSensorData.SingleDeviceSensorData

      required override internal init () {
         builderResult = MultipleDeviceSensorData.SingleDeviceSensorData()
         super.init()
      }
        var hasSource:Bool{
            get {
                return builderResult.hasSource
            }
        }
        var source:MultipleDeviceSensorData.Source {
            get {
                return builderResult.source
            }
            set (value) {
                builderResult.hasSource = true
                builderResult.source = value
            }
        }
        func setSource(value:MultipleDeviceSensorData.Source)-> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
          self.source = value
          return self
        }
        internal func clearSource() -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
           builderResult.hasSource = false
           builderResult.source = .Head
           return self
        }
      var hasData:Bool {
           get {
                return builderResult.hasData
           }
      }
      var data:NSData {
           get {
                return builderResult.data
           }
           set (value) {
               builderResult.hasData = true
               builderResult.data = value
           }
      }
      func setData(value:NSData)-> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
        self.data = value
        return self
      }
      internal func clearData() -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder{
           builderResult.hasData = false
           builderResult.data = NSData()
           return self
      }
      override internal var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      internal override func clear() -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
        builderResult = MultipleDeviceSensorData.SingleDeviceSensorData()
        return self
      }
      internal override func clone() -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
        return MultipleDeviceSensorData.SingleDeviceSensorData.builderWithPrototype(builderResult)
      }
      internal override func build() -> MultipleDeviceSensorData.SingleDeviceSensorData {
           checkInitialized()
           return buildPartial()
      }
      internal func buildPartial() -> MultipleDeviceSensorData.SingleDeviceSensorData {
        var returnMe:MultipleDeviceSensorData.SingleDeviceSensorData = builderResult
        return returnMe
      }
      internal func mergeFrom(other:MultipleDeviceSensorData.SingleDeviceSensorData) -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
        if (other == MultipleDeviceSensorData.SingleDeviceSensorData()) {
         return self
        }
        if other.hasSource {
             source = other.source
        }
        if other.hasData {
             data = other.data
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream) ->MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MultipleDeviceSensorData.SingleDeviceSensorDataBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 8 :
            let valueIntsource = input.readEnum()
            if let enumssource = MultipleDeviceSensorData.Source(rawValue:valueIntsource){
                 source = enumssource
            } else {
                 unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntsource))
            }

          case 18 :
            data = input.readData()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



    //Enum type declaration start 

    internal enum Source:Int32 {
      case Head = 0
      case Neck = 1
      case Shoulder = 2
      case Chest = 3
      case Arm = 4
      case Forearm = 5
      case Hand = 6
      case Wrist = 7
      case Waist = 8
      case Hip = 9
      case Thigh = 10
      case Calf = 11
      case Ankle = 12
      case Foot = 13

      internal static func IsValidValue(value:Int32) ->Bool {
          if let check = Source(rawValue:value) {
              return true
          }
          return false
      }
    }



    //Enum type declaration end 

  private(set) var singleDeviceSensorData:Array<MultipleDeviceSensorData.SingleDeviceSensorData>  = Array<MultipleDeviceSensorData.SingleDeviceSensorData>()
  required internal init() {
       super.init()
  }
  override internal func isInitialized() -> Bool {
    var isInitsingleDeviceSensorData:Bool = true
    for oneElementsingleDeviceSensorData in singleDeviceSensorData {
        if (!oneElementsingleDeviceSensorData.isInitialized()) {
            isInitsingleDeviceSensorData = false
            break 
        }
    }
    if !isInitsingleDeviceSensorData {
     return isInitsingleDeviceSensorData
     }
   return true
  }
  override internal func writeToCodedOutputStream(output:CodedOutputStream) {
    for oneElementsingleDeviceSensorData in singleDeviceSensorData {
        output.writeMessage(1, value:oneElementsingleDeviceSensorData)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override internal func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for oneElementsingleDeviceSensorData in singleDeviceSensorData {
        size += oneElementsingleDeviceSensorData.computeMessageSize(1)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  internal class func parseFromData(data:NSData) -> MultipleDeviceSensorData {
    return MultipleDeviceSensorData.builder().mergeFromData(data, extensionRegistry:DeviceSensorDataRoot.sharedInstance.extensionRegistry).build()
  }
  internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> MultipleDeviceSensorData {
    return MultipleDeviceSensorData.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromInputStream(input:NSInputStream) -> MultipleDeviceSensorData {
    return MultipleDeviceSensorData.builder().mergeFromInputStream(input).build()
  }
  internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MultipleDeviceSensorData {
    return MultipleDeviceSensorData.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream) -> MultipleDeviceSensorData {
    return MultipleDeviceSensorData.builder().mergeFromCodedInputStream(input).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MultipleDeviceSensorData {
    return MultipleDeviceSensorData.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func builder() -> MultipleDeviceSensorDataBuilder {
    return MultipleDeviceSensorData.classBuilder() as MultipleDeviceSensorDataBuilder
  }
  internal func builder() -> MultipleDeviceSensorDataBuilder {
    return classBuilder() as MultipleDeviceSensorDataBuilder
  }
  internal override class func classBuilder() -> MessageBuilder {
    return MultipleDeviceSensorDataBuilder()
  }
  internal override func classBuilder() -> MessageBuilder {
    return MultipleDeviceSensorData.builder()
  }
  internal func toBuilder() -> MultipleDeviceSensorDataBuilder {
    return MultipleDeviceSensorData.builderWithPrototype(self)
  }
  internal class func builderWithPrototype(prototype:MultipleDeviceSensorData) -> MultipleDeviceSensorDataBuilder {
    return MultipleDeviceSensorData.builder().mergeFrom(prototype)
  }
  override internal func writeDescriptionTo(inout output:String, indent:String) {
    var singleDeviceSensorDataElementIndex:Int = 0
    for oneElementsingleDeviceSensorData in singleDeviceSensorData {
        output += "\(indent) singleDeviceSensorData[\(singleDeviceSensorDataElementIndex)] {\n"
        oneElementsingleDeviceSensorData.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        singleDeviceSensorDataElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override internal var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementsingleDeviceSensorData in singleDeviceSensorData {
              hashCode = (hashCode &* 31) &+ oneElementsingleDeviceSensorData.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override internal class func className() -> String {
      return "MultipleDeviceSensorData"
  }
  override internal func className() -> String {
      return "MultipleDeviceSensorData"
  }
  override internal func classMetaType() -> GeneratedMessage.Type {
      return MultipleDeviceSensorData.self
  }


  //Meta information declaration end

}

final internal class MultipleDeviceSensorDataBuilder : GeneratedMessageBuilder {
  private var builderResult:MultipleDeviceSensorData

  required override internal init () {
     builderResult = MultipleDeviceSensorData()
     super.init()
  }
  var singleDeviceSensorData:Array<MultipleDeviceSensorData.SingleDeviceSensorData> {
       get {
           return builderResult.singleDeviceSensorData
       }
       set (value) {
           builderResult.singleDeviceSensorData = value
       }
  }
  func setSingleDeviceSensorData(value:Array<MultipleDeviceSensorData.SingleDeviceSensorData>)-> MultipleDeviceSensorDataBuilder {
    self.singleDeviceSensorData = value
    return self
  }
  internal func clearSingleDeviceSensorData() -> MultipleDeviceSensorDataBuilder {
    builderResult.singleDeviceSensorData.removeAll(keepCapacity: false)
    return self
  }
  override internal var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  internal override func clear() -> MultipleDeviceSensorDataBuilder {
    builderResult = MultipleDeviceSensorData()
    return self
  }
  internal override func clone() -> MultipleDeviceSensorDataBuilder {
    return MultipleDeviceSensorData.builderWithPrototype(builderResult)
  }
  internal override func build() -> MultipleDeviceSensorData {
       checkInitialized()
       return buildPartial()
  }
  internal func buildPartial() -> MultipleDeviceSensorData {
    var returnMe:MultipleDeviceSensorData = builderResult
    return returnMe
  }
  internal func mergeFrom(other:MultipleDeviceSensorData) -> MultipleDeviceSensorDataBuilder {
    if (other == MultipleDeviceSensorData()) {
     return self
    }
    if !other.singleDeviceSensorData.isEmpty  {
       builderResult.singleDeviceSensorData += other.singleDeviceSensorData
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream) ->MultipleDeviceSensorDataBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MultipleDeviceSensorDataBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = MultipleDeviceSensorData.SingleDeviceSensorData.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        singleDeviceSensorData += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}


// @@protoc_insertion_point(global_scope)
